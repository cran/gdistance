\documentclass[nojss,shortnames]{jss}
%\documentclass[article,shortnames]{jss}
\usepackage[utf8]{inputenc}
\usepackage{float}
\restylefloat{figure}
%\VignetteIndexEntry{gdistance}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% almost as usual
\author{Jacob van Etten}
\title{\proglang{R} Package \pkg{gdistance}: Distances and Routes on Geographical Grids}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Jacob van Etten} %% comma-separated
\Plaintitle{R Package gdistance: Distances and Routes on Geographical Grids} %% without formatting
\Shorttitle{\pkg{gdistance}: distances and routes on grids} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{

The \proglang{R} package \pkg{gdistance} provides classes and functions to calculate various distance measures and routes
in heterogeneous geographic spaces represented as grids. 
Least-cost distances as well as more complex distances based on (constrained) random walks can be calculated. 
Also the corresponding routes or probabilities of passing each cell can be calculated. 
The package implements classes to store the data about the probability or cost of transitioning from one cell to another on a grid in a memory-efficient sparse format. 
These classes make it possible to manipulate the values of cell-to-cell movement directly, which offers flexibility and the possibility to use asymmetric values.
The novel distances implemented in the package are used in geographical genetics (applying circuit theory), but may also have applications in other fields of geospatial analysis.
}
\Keywords{geospatial analysis, landscape genetics, circuit theory, connectivity, dispersal, travel, least-cost path, least-cost distance, random walk, \proglang{R}}
\Plainkeywords{geospatial analysis, landscape genetics, circuit theory, connectivity, dispersal, travel, least-cost path, least-cost distance, random walk, grid, R} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{}
%% \Issue{}
%% \Month{}
%% \Year{}
%% \Submitdate{}
%% \Acceptdate{}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Jacob van Etten\\
  Climate Change Adaptation Theme Group\\
  Agrobiodiversity and Ecosystem Services Programme\\
  Bioversity International\\
  c/o CATIE, Turrialba, Costa Rica\\
  E-mail: \email{jacobvanetten@yahoo.com}\\
  URL: \url{http://bioversityinternational.org}
}
 
%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

%% \section[About Java]{About \proglang{Java}}
%% Note: If there is markup in \(sub)section, then it has to be escape as above.

\section[Introduction: The Crow, the Wolf, and the Drunkard]{Introduction: The Crow, the Wolf, and the Drunkard}

This article describes \pkg{gdistance}, a package written for use in the \proglang{R} environment \citep{R}.
It provides functionality to calculate various distance measures and routes
in heterogeneous geographic spaces represented as grids.
Distances are fundamental to geospatial analysis \citep{tobler1970}.
Distances and routes are closely related concepts in geography.
The most commonly used geographic distance measure is the great-circle distance, 
which represents the shortest line between two points, 
taking into account the curvature of the earth.
The great-distance distance could be conceived of as the distance measured along a route of 
a very efficient traveller who knows where to go and has no obstacles to deal with.
In common language, this is referred to as a distance `as the crow flies'.

When travel is less goal-directed and affected by the environment, grid-based distances and routes become relevant.
The least-cost distance is implemented in most GIS software and mimics route finding `as the wolf runs'\footnote{There are some variations on this expression, involving mostly other animals, or telecom cables.}, 
taking into account obstacles and the local `friction' of the landscape. 
The random walk, which is also called the drunkard's walk, has no predetermined destination, so a destination point is hit by accident.
The distance travelled to hit the destination point is a measure used to characterize dispersal processes in geography.

Package \pkg{gdistance} was designed to determine such grid-based distances and routes 
and to make it possible to use these measures in combination with other functionality available within \proglang{R}. 
It has functionality that is comparable to other software such as ArcGIS Spatial Analyst \citep{mccoy2002}, 
GRASS GIS \citep{grass}, and CircuitScape \citep{mcrae2008}.
The gdistance package also contains specific functionality for geographical genetic analyses, not found in other software yet.
The package implements measures to model dispersal histories first presented by \cite{etten2010}.
Example 2 below introduces with an example how \pkg{gdistance} can be used in geographical genetics.

\section{Theory}

Calculations are done in various steps in \pkg{gdistance}.
At first, this tends to be somewhat confusing for those who are used to distance and route calculations in GIS software, 
which tend to be done in a single step.
However, an important goal of \pkg{gdistance} is to make the calculations of distances and routes more flexible, 
which also makes the package somewhat more complicated to use.
Users, therefore, need to have a basic understanding of the theory behind distance and route calculations.

Calculations of distances and routes start with raster data.
In geospatial analysis, rasters are rectangular, regular grids that represent continuous data over geographical space.
Cells arranged in rows and columns and each holds a value.
A raster is accompanied by metadata that indicate the resolution, extent and other properties.

Distance and route calculations on rasters rely on graph theory.
So as a first step, rasters are converted into graphs by connecting cell centres to each other, which become the nodes in the graph.
This can be done in various ways (Figure~\ref{fig:zero}).
\begin{itemize}
\item{Cells can be connected orthogonally to their four immediate neighbours, which is called the von Neumann neighbourhood.}
\item{Cells can be connected with their eight orthogonal and diagonal nearest neighbours, the Moore neighbourhood. 
The resulting graph is called the `king's graph', because it reflects all the legal movements of the king in chess.
This is the most common and often only way to connect grids in GIS software.}
\item{Connecting in 16 directions combines king's and knight's moves. 
The function r.cost in the software GRASS \citep{grass} has this as an option, which inspired its implementation in \pkg{gdistance}. 
The section on distance transforms in \cite{deSmith2009} also discusses 16-cell neighbourhoods. Connecting in 16 directions may increase the accuracy of the calculations.}
\end{itemize}

\begin{figure}[h]
\begin{center}
<<label=figure0,fig=TRUE, width=10, height=3, echo=FALSE >>=
library("gdistance")
rex <- raster(matrix(1,4,4))

a <- rep(c(1.3333),times=5)
b <- c(-1.3333, -0.6666, 0, 0.6666, 1.3333)

x1 <- c(-a, b)
x2 <- c(a, b)
y1 <- c(b, -a)
y2 <- c(b, a)
x <- cbind(x1,x2)
y <- cbind(y1,y2)

par(mfrow=c(1,3), mar = c(5,5,4,2) + 0.1,
    oma = c(0,0,0,0) + 0.1)

x4 <- transition(rex, mean, 4)
g4 <- graph.adjacency(transitionMatrix(x4), mode="undirected")
gridLayout <- xyFromCell(x4, 1:ncell(x4))
plot(g4,layout=gridLayout, edge.color="black", vertex.color="black", vertex.label=NA, main="4 cells")
for(i in 1:dim(x)[1]){lines(x[i,],y[i,], col="lightgray")}
plot(g4, layout=gridLayout, add=TRUE, edge.color="black", vertex.color="black", vertex.label=NA)

x8 <- transition(rex, mean, 8)
g8 <- graph.adjacency(transitionMatrix(x8), mode="undirected")
plot(g8,layout=gridLayout, edge.color="black", vertex.color="black", vertex.label=NA, main="8 cells")
for(i in 1:dim(x)[1]){lines(x[i,],y[i,], col="lightgray")}
plot(g8, layout=gridLayout, add=TRUE, edge.color="black", vertex.color="black", vertex.label=NA)

x16 <- transition(rex, mean, 16)
g16 <- graph.adjacency(transitionMatrix(x16), mode="undirected")
plot(g16, layout=gridLayout, edge.color="black", vertex.color="black", vertex.label=NA, , main="16 cells")
for(i in 1:dim(x)[1]){lines(x[i,],y[i,], col="lightgray")}
plot(g16,layout=gridLayout, add=TRUE, edge.color="black", vertex.color="black", vertex.label=NA)

@
\end{center}
\vspace{-20pt}
\caption{Rasters can be converted into graphs in different ways.}
\label{fig:zero}
\end{figure}

When the raster is converted into a graph, weights are given to each edge (connections between nodes).
These weights correspond to different concepts.
In most GIS software, distance analyses are done with calculations using cost, friction or resistance values.
In graph theory, weights can also correspond to conductance (1/resistance), which is equivalent to permeability (a term used in landscape ecology).
The weights can also represent probabilities of transition.

Graphs are mathematically represented as matrices to do calculations.
Matrices can include transition probability matrices, adjacency matrices, resistance/conductance matrices, Laplacian matrices, among others.
In \pkg{gdistance}, we refer collectively to matrices that represent graphs as `transition matrices'.
These transition matrices are the central object in the package; all distance calculations need one or more transition matrices as an input.

In \pkg{gdistance}, usually conductance rather than resistance values are expected in the transition matrix.
An important advantage of using conductance is that it makes it possible to use computer memory very efficiently, using so-called \emph{sparse} matrices. 
Sparse matrices only record the non-zero values and information about their location in the matrix.
In most cases, cells are connected only with adjacent cells, and the conductance for direct connections between remote cells is zero.
Consequently, most values in a conductance matrix are zero and occupy no memory in a sparse matrix.
Another reason is that in graph theory the analogy of a graph with an electrical circuit is often used 
(see below). 
For most calculations based on this analogy, the conductance matrix or the transition probability matrix are used.

The calculation of the actual edge weights is usually based on the values of the grid cells, 
which represents a property of the landscape.
For instance, from a grid with altitude, a value for the ease of walking can be calculated for each transition between cells.
It is possible to create asymmetric matrices, in which the conductance from i to j is not always the same as 
the conductance from j back to i. 
This is relevant, among other things, for modelling travel in hilly terrain, as shown in Example 1 below. 
On the same slope, a downslope traveler experiences less friction than an upslope traveler.
In this case, the function to calculate conductance values is non-commutative: $f(i,j) \neq f(j,i)$.

A problem that arises in grid-based modelling is the choice of weights that should be given to diagonal edges in proportion to orthogonal ones.
For least-cost path distance and routes, this is fairly straightforward: weights are given in proportion to the distances between the cell centres.
In a grid in which the orthogonal edges have a length of 1, the diagonal edges are  $\sqrt[]{2}$ long.
\cite{mcrae2006} also applies this same idea to random walks.
However, as \cite{birch2006} explains, this is generally not the best discrete approximation of a random walk dispersal process in continuous space. 
Different orthogonal and diagonal weights could be considered based on his analytical results.

For random walks on longitude-latitude grids, there is an additional consideration to be made.
Considering the eight neighbouring cells in a Moore's neighbourhood, 
the three cells that are located nearer to the equator are larger in area than the three cells 
that are closer to the nearest pole, as the meridians approach each other. 
So the latter should have a slightly lower probability of being reached during a random walk from the central cell.
More theoretical work is needed to investigate possible solutions to this problem.
For projected grids, we can safely ignore this distortion problem.

When the transition matrix has been constructed, different algorithms to calculate distances and routes are applied.
\begin{itemize}
\item{The least-cost distance mimics route finding `as the fox runs', taking into account obstacles and the local `friction' 
of the landscape. The least-cost path between two cells on the grid and the associated distance can be obtained with Dijkstra's algorithm 
or similar algorithms. }
\item{A second type of route-finding is the random walk, which has no predetermined destination 
(a `drunkard's walk'). 
Commute distance represents the random walk commute time, 
which is the average number of edges traversed during a random walk from an starting point on the graph to a destination point and back again to the starting point \citep{chandra1996}. 
Resistance distance reflects the average travel \emph{cost} during this walk \citep{mcrae2006}. 
When taken on the same graph these two measures differ only in their scaling \citep{kivimaki2012}.
Commute and resistance distances 
are calculated using the analogy with an electrical circuit \cite[see][for an introduction]{doyle1984}.
The algorithm that \pkg{gdistance} uses to calculate commute distances was developed by \cite{fouss2007}}.
\item{Randomised shortest paths are an intermediate form between shortest paths and Brownian random walks, introduced by \cite{saerens2009}. 
\cite{etten2010} applied randomised shortest paths in geospatial analysis (and see Example 2 below).}
\end{itemize}

\section{Raster Basics}

Analyses in \pkg{gdistance} start with one or more rasters.
For this, it relies on another \proglang{R} package, \pkg{raster} \cite{hijmans2012}.
The \pkg{raster} package provides comprehensive geographical grid functionality.
Here, we briefly discuss this package,  
referring the reader to the documentation of \pkg{raster} itself for more information.

The following code shows how to create a raster object.

<<label=gdistanc00, echo = FALSE>>=
options(prompt = "R> ", continue = "+  ", width = 70, useFancyQuotes = FALSE)
@

<<gdistance-1>>=
r <- raster(ncol=3,nrow=3)
r[] <- 1:ncell(r)
r
@

The first line loads the package. 
The second line creates a simple raster with 3 columns and 3 rows.
The third line assigns the values 1 to 9 as the values of the cells.
The resulting object is inspected in the fourth line. 
As can be seen in the output, the object does not only hold the cell values, but also holds metadata about the geographical properties of the raster.

It can also be seen that this is an object of the class \code{RasterLayer}.
This class is for object that hold only one layer of grid data.
There are other classes which allow more than one layer of data: \code{RasterStack} and \code{RasterBrick}.
Collectively these classes are referred to as \code{Raster*}.

A class is a static entity designed to represent objects of a certain type using `slots', which each hold different information about the object.
Both \pkg{raster} and \pkg{gdistance} use so-called S4 classes, a formal object-oriented system in \proglang{R}.
An advantage of using classes is that data and metadata stay together and remain coherent. 
Consistent use of classes makes it more difficult to have contradictions in the information about an object. 
For instance, changing the number of rows of a grid also has an effect on the total number of cells.
Information about these two types of information of the same object could become contradictory if we were allowed to change one without adjusting the other.
Classes make operations more rigid to avoid such contradictions.
Operations that are geographically incorrect, such as adding the values of two rasters of different projections, 
are detected by first comparing the content of the slots that hold the projection information of the two objects.
If the information about the projections used for the rasters are not compatible, the operation will produce an error.

Classes also make it easier for the users to work with complex data and functions.
Since so much information can be stored in a consistent way in objects and passed to functions, 
these functions need fewer options.
Functions can deduce from the class of the object that is given to it, what it needs to do.
The use of classes, if well done, tends to produce cleaner, better readable, and more consistent scripts.

One important thing to know about \pkg{raster} is how grid data are stored internally in \code{Raster*} objects.
Cell numbers in rasters go from left to right and from top to bottom.
The 3 x 3 raster we just created with its cell numbers is shown in Figure~\ref{fig:one}.

\begin{figure}[h]
\begin{center}
<<label=figure1,fig=TRUE,height = 3.9, echo=FALSE >>=
plot(r, main="r")
text(r)
@
\end{center}
\caption{Cell numbers of a 3 x 3 raster.}
\label{fig:one}
\end{figure}

Figure~\ref{fig:one} can be made with this code.

<<gdistance-2>>=
plot(r, main="r")
text(r)
@

\section[Transition* Classes]{\code{Transition*} Classes}
As explained in Section 2 on the theory behind \pkg{gdistance}, transition matrices are the backbone of the package.
The central classes in \pkg{gdistance} are \code{TransitionLayer} and \code{TransitionStack}. 
Most operations have an object of one of these classes either as input and sometime also as their output.

\code{Transition*} objects can be constructed from an object of class \code{Raster*}.
The class \code{Transition*} takes the necessary geographic references (projection, resolution, extent) from the original \code{Raster*} object. 
It also contains a matrix which represents a transition from one cell to another in the grid.
Each row and column in the matrix represents a cell in the original \code{Raster*} object.
Row 1 and column 1 in the transition matrix corresponds to cell 1 in the original raster, row 2 and column 2 to cell 2, and so on.
For instance, the raster we just created would produce a 9 x 9 transition matrix with rows and columns numbered from 1 to 9 (see Figure~\ref{fig:two} below).

The matrix is stored in a sparse format, as discussed in Section 2.
The package \pkg{gdistance} makes use of sparse matrix classes and methods from the package \code{Matrix}, 
which gives access to fast procedures implemented in the \proglang{C} language \citep{maechler2012}.

The construction of a \code{Transition*} object from a \code{Raster*} object is straightforward. 
We can define an arbitrary function to calculate the conductance values from the values of each pair of cells to be connected.

In the following chunk of code, the \code{RasterLayer} created earlier is used.
Then we set all its values to unit.
The next line makes a \code{TransitionLayer}, setting the transition value between each pair of cells to the mean of the two cell values that are being connected.
The \code{directions} argument is set to 8, which connects all cells to their 8 neighbours (Moore neighbourhood). 

<<gdistance-3>>=
library("gdistance")
r[] <- 1
tr1 <- transition(r, transitionFunction=mean, directions=8)
@

If we inspect the object we created, we see that the resulting \code{TransitionLayer} object keeps much information from 
the original \code{RasterLayer} object.
<<gdistance-4>>=
tr1
@

To make an asymmetric transition matrix, the \code{symm} argument in \code{transition} needs to be set to \code{FALSE}.
<<gdistance-5>>=
r[] <- runif(9)
ncf <- function(x) max(x) - x[1] + x[2]
tr2 <- transition(r, ncf, 4, symm=FALSE)
tr2
@
\noindent From the `matrix class' we can deduce if the matrix is symmetric or not.
These classes are defined in the package \pkg{Matrix} \citep{maechler2012}.
The class \code{dsCMatrix} is for matrices that are symmetric.
The class \code{dgCMatrix} holds an asymmetric matrix.

Different mathematical operations can be done with \code{Transition*} objects. 
This makes it possible to flexibly model different components of landscape friction.
<<gdistance-6>>=
tr3 <- tr1*tr2
tr3 <- tr1+tr2
tr3 <- tr1*3
tr3 <- sqrt(tr1)
@
\noindent Operations with more than one object require that the different objects have the same resolution and extent.

Also, it is possible to extract and replace values in the matrix using indices,
in a similar way to the use of indices with simple matrices.
<<gdistance-7>>=
tr3[cbind(1:9,1:9)] <- tr2[cbind(1:9,1:9)]
tr3[1:9,1:9] <- tr2[1:9,1:9]
tr3[1:5,1:5]
@

The functions \code{adjacent} (from \pkg{raster}) and \code{adjacencyFromTransition} (from \pkg{gdistance}) can be used to create indices.
Example 1 below gives an example.

Some functions require that \code{Transition*} objects do not contain any isolated `clumps', islands that are not connected to the rest of the raster cells. 
This can be avoided when creating \code{Transition*} objects, 
for instance by giving conductance values between all adjacent cells a small minimum value.
It can be checked visually if there are any clumps. 
There are several ways to visualize a \code{Transition*} object.
For the first method, you can extract the transition matrix with function \code{transitionMatrix}.
This gives a sparse matrix which can be vizualized with function \code{image}.
This shows the rows and columns of the transition matrix and indicates which has a non-zero value, which represents a connection between cells (Figure~\ref{fig:two}).

<<gdistance-8, eval=FALSE>>=
image(transitionMatrix(tr1))
@
\begin{figure}[h]
\begin{center}
<<label=figure2,fig=TRUE,height = 4, echo=FALSE >>=
print(image(transitionMatrix(tr1)))
@
\end{center}
\caption{Visualizing a TransitionLayer with function \code{image}.}
\label{fig:two}
\end{figure}

Figure~\ref{fig:two} shows which cells are connected to each other.
A close observer of Figure~\ref{fig:two} may wonder why even cell 1 is connected to 5 different cells, as this cell is located in the upper left corner of the original grid.
This is explained by the extent of the grid.
Since it covers the whole world, the outer meridians (180 and -180 degrees) touch each other.
The software takes this into account and as a result the cells in the extreme left column are connected to the extreme right column.

Figure~\ref{fig:two} shows which cells contain non-zero values, but gives no further information about levels of conductance.
This can be visualized by transforming the transition matrix back into a raster.
To summarize the information in transition matrix, we can take means or sums across rows or columns, for instance.
You can do this with function \code{raster}. 
Applied to a \code{TransitionLayer}, this function converts it to a \code{RasterLayer}. 
For the different options see \code{method?raster("TransitionLayer")}. 
The default, shown in Figure~\ref{fig:three}, takes the column-wise means of the non-zero values.

\begin{figure}[h]
\begin{center}
<<label=figure3,fig=TRUE,height = 3.8 >>=
plot(raster(tr3), main="raster(tr3)")
@
\end{center}
\caption{Visualizing a TransitionLayer using the function \code{raster}.}
\label{fig:three}
\end{figure}

\section{Correcting Transition Matrix Values}
The function \code{transition} calculates transition values based on the values of adjacent cells in the input raster.
However, diagonal neighbours are more remote from each other than orthogonal neighbours.
Secondly, on equirectangular (longitude-latitude) grids, West-East connections are longer at the equator and become shorter towards the poles, as the meridians approach each other.
Therefore, the values in the matrix need to be corrected for these two types of distortion.
Both types of distortion can be corrected by dividing each conductance matrix value by the distance between cell centres.
This is what function \code{geoCorrection} does.

<<gdistance-9>>=
tr1C <- geoCorrection(tr1, type="c", multpl=FALSE)
tr2C <- geoCorrection(tr2, type="c", multpl=FALSE)
@

For least-cost type distances and routes, this works fine.
However, as explained in Section 2 above, this does not work equally well for commute distances (random walks).
The function geoCorrection corrects this distortion by multiplying the 
North-South transition values with the cosine of the average latitude of the cell centres.
This type of correction is done by setting the argument \code{type} to \code{"r"}.

<<gdistance-10>>=
r3 <- raster(ncol=18, nrow=9)
r3 <- setValues(r3, runif(18*9)+5)
tr3 <- transition(r3, mean, 4)
tr3C <- geoCorrection(tr3, type="c", multpl=FALSE, scl=TRUE)
tr3R <- geoCorrection(tr3, type="r", multpl=FALSE, scl=TRUE)
@

As mentioned in Section 2, the effect of these distortions and corrections needs more research.

The argument \code{scl} is set to \code{TRUE} to get reasonable values. 
If the values are too large, commute distance and randomized shortest path functions will not work well.

When similar \code{Transition*} objects with equal resolution and extent need to be corrected repetitively, 
computational effort may be reduced by
preparing an object that only needs to be multiplied with the \code{Transition*} object to produce a corrected version of it.
The following chunk of code is equivalent to the previous one.

<<gdistance-11>>=
CorrMatrix <- geoCorrection(tr3, type="r", multpl=TRUE, scl=TRUE)
tr3R <- tr3 * CorrMatrix
@

\noindent Object \code{CorrMatrix} is only calculated once.
It can be multiplied with \code{Transition*} objects, as long as they have the same extent, resolution, 
and directions of cell connections.
We need to take special care that the geo-correction multiplication matrix (\code{CorrMatrix}) contains all non-zero values that are
present in the \code{Transition*} object with which it will be multiplied (\code{tr3} in this case).

\section{Calculating Distances}
Only now that we have the corrected \code{Transition*} object we can calculate distances between points.
It is important to note that all distance functions require a \code{Transition*} object with \emph{conductance} values,
even though distances will be expressed in 1/conductance (friction or resistance) units (see Section 3).

To calculate distances, we need to have the coordinates of point locations.
This is done by creating a two-column matrix of coordinates.
Functions will also accept a \code{SpatialPoints} object or, if there is only one point, a vector of length two.

<<gdistance-12>>=
sP <- cbind(c(-100, 100, -100), c(-50, 50, 50))
@

\noindent Calculating a distance matrix is straightforward now.

<<gdistance-13>>=
costDistance(tr3C, sP)
commuteDistance(tr3R, sP)
rSPDistance(tr3R, sP, sP, theta=1e-12, totalNet="total")
@

The \code{costDistance} function relies on the package \pkg{igraph} \citep{csardi2006} for the underlying calculation.
It gives a symmetric or asymmetric distance matrix, depending on the \code{TransitionLayer} that is used as input.

Commute distance represents the random walk commute time, which represents the number of cells traversed on the trip \citep{chandra1996}.

\code{rSPDistance} gives the cost incurred during the same walk (theta approaches zero, so the walk is nearly random). 
By summing the corresponding off-diagonal elements (Dij + Dji), we obtain the commute costs. 
In this case, the commute costs are only slightly higher than (and proportional to) the commute distances. 
This is because the TransitionLayer object has been scaled, so transition costs are close to unit for each step.
So the total number of steps and the total distance are in the same order.

\section{Dispersal Paths}

To determine dispersal paths of a (constrained) random walk, we use the function \code{passage}. 
This function can be used for both random walks and randomised shortest paths.
The function calculates the number of passages through cells before arriving in the destination cell.
Either the total or net number of passages can be calculated.
The net number of passages is the number of passages that are not reciprocated by a passage in the opposite direction.

Figure~\ref{fig:four} shows the probability of passage through each cell, assuming randomised shortest paths with the parameter theta set to 3.

<<gdistance-14>>=
origin <- SpatialPoints(cbind(0, 0))
rSPraster <- passage(tr3C, origin, sP[3,], theta=3)
@
\begin{figure}[H]
\begin{center}
<<label=figure4,fig=TRUE,height = 3.8, echo=FALSE >>=
plot(rSPraster, main="rSPraster")
@
\end{center}
\caption{Probability of passage.}
\label{fig:four}
\end{figure}

\section{Path Overlap and Non-Overlap}
One of the specific uses, for which package gdistance was created,
is to look at trajectories coming from the same source \citep{etten2010}. 
The degree of coincidence of two trajectories can be visualized by multiplying the probabilities of passage (Figure~\ref{fig:five}).
With a more complex formula, we can approximate the non-overlapping part of the trajectory (Figure~\ref{fig:six}).
\vspace{-1.0em}
<<gdistance-15>>=
r1 <- passage(tr3C, origin, sP[1,], theta=1)
r2 <- passage(tr3C, origin, sP[3,], theta=1)
rJoint <- min(r1, r2) #Figure 6
rDiv <- max(max(r1, r2) * (1 - min(r1, r2)) - min(r1, r2), 0) #Figure 7
@
\vspace{-1.0em}
\begin{figure}[H]
\begin{center}
<<label=figure5,fig=TRUE,height = 3.75, echo=FALSE >>=
plot(rJoint, main="rJoint")
@
\end{center}
\vspace{-20pt}
\caption{Overlapping part of the two routes.}
\label{fig:five}
\end{figure}
\vspace{-1.0em}
\begin{figure}[H]
\begin{center}
<<label=figure6,fig=TRUE,height = 3.75, echo=FALSE >>=
plot(rDiv, main="rDiv")
@
\end{center}
\vspace{-20pt}
\caption{Non-overlapping part of the two routes.}
\label{fig:six}
\end{figure}

With the function \code{pathInc} we can calculate measures of path overlap and non-overlap
for a large number of points.
These measures can be used to predict patterns of diversity if these are due to dispersal from a single common source (van Etten and Hijmans 2010).
If the argument type contains two elements (divergent and joint), the result is a list of distances matrices.

<<gdistance-17>>=
pathInc(tr3C, origin, sP)
@

\section{Example 1: Hiking around Maunga Whau}
The previous examples were somewhat theoretical, based on randomly generated values.
More realistic examples serve to illustrate the various uses that can be given to this package.

Determining the fastest route between two points in complex terrain is useful for hikers.
Tobler's Hiking Function provides a rough estimate for the the maximum hiking speed given the slope of the terrain \citep{tobler1993}.
The maximum speed of off-path hiking (in m/s) is:

\begin{math}
speed = exp(-3.5 * abs(slope + 0.05))
\label{formula1}
\end{math}

\noindent Note that the function is not symmetric around 0 (see Figure~\ref{fig:seven}).

\begin{figure}[h]
\begin{center}
<<label=figure7,echo=FALSE,fig=TRUE,height = 3.8 >>=
plot(function(x)exp(-3.5 * abs(x + 0.05)), -1, 1, xlab="slope", ylab="speed (m/s)")
lines(cbind(c(0,0),c(0,3.5)), lty="longdash")
@
\end{center}
\caption{Tobler's Hiking Function.}
\label{fig:seven}
\end{figure}

We use the Hiking Function to determine the shortest path to hike around the volcano Maunga Whau (Auckland, New Zealand).
First, we read in the altitude data for the volcano.
This is a geo-referenced version of a \proglang{R} base dataset (see \code{?volcano}).

<<gdistance-18>>=
r <- raster(system.file("external/maungawhau.grd", 
  package="gdistance"))
@

The Hiking Function requires the slope as input.

\begin{math}
slope = difference in height / distance travelled
\label{formula2}
\end{math}

The units of height and distance should be identical.
Here, we use meters for both.
We calculate the height differences between cells first.
Then we use the function \code{geoCorrection} to divide by the distance between cells.
<<gdistance-19, keep.source=TRUE>>=
heightDiff <- function(x){x[2] - x[1]}
hd <- transition(r,heightDiff,8,symm=FALSE)
slope <- geoCorrection(hd, scl=FALSE)
@
Subsequently, we calculate the speed.
We need to exercise special care, because the matrix values between non-adjacent cells is 0, but the slope between these cells is not 0!
Therefore, we need to restrict the calculation to adjacent cells.
We do this by creating an index for adjacent cells (\code{adj}) with the function \code{adjacent}.
Using this index, we extract and replace adjacent cells, without touching the other values.
<<gdistance-20>>=
adj <- adjacent(r, cells=1:ncell(r), pairs=TRUE, directions=8)
speed <- slope
speed[adj] <- exp(-3.5 * abs(slope[adj] + 0.05))
@
Now we have calculated the speed of movement between adjacent cells.
We are close to having the final conductance values.
Attainable speed is a measure of the ease of crossing from one cell to another on the grid.
However, we also need to take into account the distance between cell centres.
Travelling with the same speed, a diagonal connection between cells takes longer to cross than a straight connection.
Therefore, we use the function \code{geoCorrection} again!
<<gdistance-21>>=
x <- geoCorrection(speed, scl=FALSE) 
@
This gives our final `conductance' values.

What do these values mean?
The function \code{geoCorrection} divides the values in the matrix between the distance between cell centres.
So, with our last command we calculated this:

\begin{math}
conductance = speed / distance
\label{formula3}
\end{math}

This looks a lot like a measure that we are more familiar with: 

\begin{math}
travel time = distance / speed
\label{formula4}
\end{math}

In fact, the conductance values we have calculated are the \emph{reciprocal} of travel time.

\begin{math}
1 / travel time = speed / distance = conductance
\label{formula5}
\end{math}

Maximizing the reciprocal of travel time is exactly equivalent to minimizing travel time!

Now we define two coordinates, A and B, and determine the paths between them.
We test if the quickest path from A to B is the same as the quickest path from B back to A.
The following code creates the shortest paths.

<<gdistance-22>>=
A <- c(2667670,6479000)
B <- c(2667800,6479400)
AtoB <- shortestPath(x, A, B, output="SpatialLines")
BtoA <- shortestPath(x, B, A, output="SpatialLines")
@

And this code was used to make Figure~\ref{fig:eight}.

<<label=fig8plot,include=FALSE>>=
plot(r, main="")
lines(AtoB, col="red", lwd=2)
lines(BtoA, col="blue")
text(A[1]-10,A[2]-10,"A")
text(B[1]+10,B[2]+10,"B")
@

A small part of the A-B (red) and B-A (blue) lines in Figure~\ref{fig:eight} do not overlap.
This is a consequence of the asymmetry of the Hiking Function.

\begin{figure}[h]
\begin{center}
<<label=fig8,fig=TRUE,echo=FALSE, height = 6>>=
<<fig8plot>>
@
\end{center}
\caption{Quickest hiking routes on Maunga Whau 
(A to B is red, B to A is blue).}
\label{fig:eight}
\end{figure}
\clearpage
\section{Example 2: Geographical Genetics}

The direct relation between genetic and geographic distances is known as \emph{isolation by distance} \citep{wright1943}.
Recent work has expanded this relationship to random movement in heterogeneous landscapes \citep{mcrae2006}.
Also, the geography of dispersal routes can explain observed geospatial patterns of genetic diversity.
For instance, diffusion from a single origin (Africa) explains much of the current geographical patterns of human genetic diversity \citep{ram2005}.
As a result, the mutual genetic distance between a pair of humans from different parts from the globe depends on the extent 
they share their prehistoric migration history.

Within a single continent, however, human genetic diversity may have to do with more recent events.
Let's look at diversity in Europe, using the data presented by \cite{bal2010}.
Within Europe, genetic diversity is often thought to be a result of the migration of early Neolithic farmers from Anatolia (Turkey) to the west.

First we read in the data, including the coordinates of the populations (see Figure~\ref{fig:nine}) and mutual genetic distances.

<<gdistance-24>>=
Europe <- raster(system.file("external/Europe.grd", 
  package="gdistance"))
Europe[is.na(Europe)] <- 0
data(genDist)
data(popCoord)
pC <- as.matrix(popCoord[c("x","y")])
@

\begin{figure}[h]
\begin{center}
<<fig=TRUE,echo=FALSE, height=6>>=
plot(Europe, main="")
text(pC[,1],pC[,2],unlist(popCoord["Population"]),cex=.7)
@
\end{center}
\caption{Map of genotyped populations.}
\label{fig:nine}
\end{figure}

Then we create three geographical distance matrices.
The first corresponds to the great-circle distance between populations.
The second is the least-cost distance between locations. Travel is restricted to the land mass.
The third is the commute distance (using the same conductance matrix), 
which is related to effective resistance between points if we conceive of the grid as an electrical circuit \citep{chandra1996,mcrae2006}.

<<gdistance-25>>=
geoDist <- pointDistance(pC, longlat=TRUE)
geoDist <- as.dist(geoDist)
Europe <- aggregate(Europe,3)
tr <- transition(Europe, mean, directions=8)
trC <- geoCorrection(tr, "c", scl=TRUE)
trR <- geoCorrection(tr, "r", scl=TRUE)
cosDist <- costDistance(trC,pC)
resDist <- commuteDistance(trR, pC)
cor(genDist,geoDist)
cor(genDist,cosDist)
cor(genDist,resDist)
@

Amont the measure evaluated until now, the great-circle distance between points turns out to be the best predictor of genetic distance.
The other distance measures incorporate more information about the geographic space in which geneflow takes place, 
but do not improve the prediction.
But how well does an expansion from Anatolia explain the spatial pattern?

<<gdistance-26>>=
origin <- unlist(popCoord[22,c("x","y")])
pI <- pathInc(trC, origin=origin, from=pC, 
  functions=list(overlap))
cor(genDist,pI[[1]])
@

At least at first sight, the overlap of dispersal routes explain the spatial pattern better than any of the previous measures.
The negative sign of the last correlation coefficient was expected, as more overlap in routes is associated with lower genetic distance.
Additional work would be needed to improve predictions and compare the different models more rigorously.

\section{Future Work}
Improvements of \pkg{gdistance} and methodological refinements are expected in various areas. 
\begin{itemize}
\item{
All measures based on random walks depend critically on solving sparse linear systems.
This is the most time-consuming part of the calculations.
Faster libraries could improve the \pkg{gdistance} package and may become available in \proglang{R} in the future.
}
\item{
Research on distances in graph theory is a very dynamic field in the computational sciences.
New measures and algorithms could be added to \pkg{gdistance} when they become available.
}
\item{
More research on the consequences of connecting grids in different ways is necessary, as indicated in Section 2. 
This should bring more precision to random walk calculations in geospatial analysis.
Comparing the results of grid-based calculations to continuous space simulations or analytical solutions would be the way forward \citep{birch2006}.
}
\end{itemize}
\section{Final Remarks}
Questions about the use of \pkg{gdistance} can be posted on the r-sig-geo email list.
Bug reports and requests for additional functionality can be mailed to jacobvanetten@yahoo.com.

\bibliography{gdistance2}

\end{document}